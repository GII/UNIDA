/**
 * *****************************************************************************
 *
 * Copyright (C) 2013 Mytech Ingenieria Aplicada <http://www.mytechia.com>
 * Copyright (C) 2013 Victor Sonora <victor@vsonora.com>
 *
 * This file is part of UNIDA.
 *
 * UNIDA is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * UNIDA is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with UNIDA. If not, see <http://www.gnu.org/licenses/>.
 *
 *****************************************************************************
 */
package com.unida.tools.librarybasicgui.dialog;

import com.mytechia.commons.framework.exception.InternalErrorException;
import com.mytechia.commons.framework.modelaction.exception.InstanceNotFoundException;
import com.unida.library.device.Gateway;
import com.unida.library.manage.im.InMemoryUniDAInstantiationFacade;
import com.unida.library.operation.OperationFailures;
import com.unida.library.operation.OperationTicket;
import com.unida.library.operation.gateway.IAutonomousBehaviourCallback;
import com.unida.protocol.UniDAAddress;
import com.unida.protocol.message.autonomousbehaviour.UniDAABRuleVO;
import com.unida.protocol.message.autonomousbehaviour.trigger.RuleTrigger;
import com.unida.tools.librarybasicgui.UNIDALibraryBasicGUI;
import java.awt.Component;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;

/**
 * Dialog class that handles everything related to the autonomous behaviour
 * rules associated with an UniDA gateway
 *
 * @author victor
 */
public class ManageAutonomousBehaviourRulesDialog extends javax.swing.JDialog
{

    private InMemoryUniDAInstantiationFacade instantiationFacade;
    private String gatewayAddress;
    private Collection<RuleTrigger> triggers;

    /**
     * Creates new form, initialazing the GUI components
     *
     * @param parent
     * @param modal
     * @param instantiationFacade
     * @param gatewayAddress
     */
    public ManageAutonomousBehaviourRulesDialog(java.awt.Frame parent, boolean modal,
            InMemoryUniDAInstantiationFacade instantiationFacade, String gatewayAddress)
    {
        super(parent, modal);
        
        this.instantiationFacade = instantiationFacade;
        this.gatewayAddress = gatewayAddress;
        this.triggers = new ArrayList<>();        
        
        initComponents();
        initComponentsCustom(); 

        this.setTitle(this.getTitle() + ": " + gatewayAddress);

    }

    
    /*
    * Asks the instantiationFacade for the data of the detected UniDA gateways
    * The actual GUI work is done by the callback
    */
    private void loadABRules()
    {
        try
        {

            Gateway gateway = instantiationFacade.getDeviceManageFacade().findDeviceGatewayById(gatewayAddress);

            instantiationFacade.getGatewayOperationFacade().requestABRules(gateway.getId(), new ABCallback());

        } catch (InternalErrorException | InstanceNotFoundException ex)
        {
            JOptionPane.showMessageDialog(this, ex.toString());
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        buttonGroupTriggerType = new javax.swing.ButtonGroup();
        buttonGroupActionType = new javax.swing.ButtonGroup();
        jScrollPaneABRules = new javax.swing.JScrollPane();
        jTableABRules = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jButtonRemoveABRule = new javax.swing.JButton();
        jButtonRefreshABRules = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Autonomous behaviour management");

        jTableABRules.setFont(new java.awt.Font("Lucida Grande", 0, 10)); // NOI18N
        jTableABRules.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][]
            {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String []
            {
                "Trigger", "Action Type", "Action", "Index"
            }
        )
        {
            Class[] types = new Class []
            {
                java.lang.String.class, java.lang.Object.class, java.lang.Object.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean []
            {
                false, false, false, false
            };

            public Class getColumnClass(int columnIndex)
            {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex)
            {
                return canEdit [columnIndex];
            }
        });
        jTableABRules.setColumnSelectionAllowed(true);
        jTableABRules.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPaneABRules.setViewportView(jTableABRules);
        jTableABRules.getColumnModel().getSelectionModel().setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        if (jTableABRules.getColumnModel().getColumnCount() > 0)
        {
            jTableABRules.getColumnModel().getColumn(1).setPreferredWidth(100);
            jTableABRules.getColumnModel().getColumn(1).setMaxWidth(100);
            jTableABRules.getColumnModel().getColumn(2).setPreferredWidth(350);
            jTableABRules.getColumnModel().getColumn(2).setMaxWidth(350);
            jTableABRules.getColumnModel().getColumn(3).setPreferredWidth(50);
            jTableABRules.getColumnModel().getColumn(3).setMaxWidth(50);
        }

        jLabel1.setText("Autonomous Behaviour Rules:");

        jButtonRemoveABRule.setText("Delete Selected Rule");
        jButtonRemoveABRule.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jButtonRemoveABRuleActionPerformed(evt);
            }
        });

        jButtonRefreshABRules.setText("Refresh rules");
        jButtonRefreshABRules.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                jButtonRefreshABRulesActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPaneABRules)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 341, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(232, 232, 232)
                        .addComponent(jButtonRefreshABRules)
                        .addGap(246, 246, 246)
                        .addComponent(jButtonRemoveABRule)))
                .addContainerGap(319, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPaneABRules, javax.swing.GroupLayout.PREFERRED_SIZE, 166, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonRemoveABRule)
                    .addComponent(jButtonRefreshABRules))
                .addGap(5, 5, 5))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void initComponentsCustom()
    {
        for (int i = 0; i < jTableABRules.getColumnCount(); i++)
        {
            TableColumn col = jTableABRules.getColumnModel().getColumn(i);
            col.setCellRenderer(new CustomCellRenderer());
        }

        jTableABRules.getSelectionModel().addListSelectionListener(new ListSelectionListener()
        {

            @Override
            public void valueChanged(ListSelectionEvent e)
            {
                if (e.getValueIsAdjusting())
                {
                    return;
                }
                ListSelectionModel lsm = (ListSelectionModel) e.getSource();
                if (lsm.isSelectionEmpty())
                {
                    System.out.println("No rows are selected.");
                } else
                {
                    int selectedRow = lsm.getMinSelectionIndex();
                    Object valueAt = jTableABRules.getModel().getValueAt(selectedRow, 0);
                    if (null != valueAt && valueAt.toString().length() > 0)
                    {
                        jButtonRemoveABRule.setEnabled(true);
                    } else
                    {
                        jButtonRemoveABRule.setEnabled(false);
                    }
                }
            }
        });

        UNIDALibraryBasicGUI.cleanJTable(jTableABRules);      

        jButtonRemoveABRule.setEnabled(false);
        
    }


    /*
    * If there is a selected row in the rules table, picks its ID
    *and launches an UniDA gateway operation to delete that rule
    */
    private void jButtonRemoveABRuleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRemoveABRuleActionPerformed
        if (jTableABRules.getSelectedRowCount() > 0)
        {
            try
            {
                Integer ruleID = (Integer) jTableABRules.getModel().getValueAt(jTableABRules.getSelectedRow(), 3);

                instantiationFacade.getGatewayOperationFacade().rmABRule(new UniDAAddress(gatewayAddress), ruleID);
            } catch (InternalErrorException ex)
            {
                JOptionPane.showMessageDialog(this, ex.toString());
            }
        }
    }//GEN-LAST:event_jButtonRemoveABRuleActionPerformed

    

    private void jButtonRefreshABRulesActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jButtonRefreshABRulesActionPerformed
    {//GEN-HEADEREND:event_jButtonRefreshABRulesActionPerformed
        loadABRules();
    }//GEN-LAST:event_jButtonRefreshABRulesActionPerformed
   
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroupActionType;
    private javax.swing.ButtonGroup buttonGroupTriggerType;
    private javax.swing.JButton jButtonRefreshABRules;
    private javax.swing.JButton jButtonRemoveABRule;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPaneABRules;
    private javax.swing.JTable jTableABRules;
    // End of variables declaration//GEN-END:variables

    
    /*
    * Callback that is invoked when an answer for an UniDA autonomous behaviour rules query
    *is received
    */
    private class ABCallback implements IAutonomousBehaviourCallback
    {

        @Override
        public void notifyGatewayAutonomousBehaviourRules(OperationTicket ticket, Gateway gateway, List<UniDAABRuleVO> rules)
        {

            UNIDALibraryBasicGUI.cleanJTable(jTableABRules);
            int ruleRow = 0;

            for (UniDAABRuleVO rule : rules)
            {
                String triggersText = "";
                for (RuleTrigger trigger : rule.getTriggers())
                {
                    triggersText += trigger.toString();
                }
                jTableABRules.getModel().setValueAt(triggersText, ruleRow, 0);
                jTableABRules.getModel().setValueAt(rule.getAction().getType().toString(), ruleRow, 1);
                jTableABRules.getModel().setValueAt(rule.getAction().toString(), ruleRow, 2);
                jTableABRules.getModel().setValueAt(rule.getRuleId(), ruleRow, 3);
                ruleRow++;
            }
        }

        @Override
        public void notifyAutonomousBehaviourScenarios(OperationTicket ticket, List<String> scenarioIDs)
        {
            throw new UnsupportedOperationException("Not supported here.");
        }

        @Override
        public void notifyAutonomousBehaviourACK(OperationTicket ticket)
        {
            throw new UnsupportedOperationException("Not supported yet.");
        }

        @Override
        public void notifyExecution(OperationTicket ticket)
        {
            throw new UnsupportedOperationException("Not supported yet.");
        }

        @Override
        public void notifyFailure(OperationTicket ticket, OperationFailures failure)
        {
            JOptionPane.showMessageDialog(ManageAutonomousBehaviourRulesDialog.this, "Oh no!");
        }

    }

    
    /*
    * A different cellRenderer is needed to be able to handle a different 
    *tooltip text for each cell
    */
    private class CustomCellRenderer extends JLabel implements TableCellRenderer
    {

        // This method is called each time a cell in a column
        // using this renderer needs to be rendered.
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int rowIndex, int vColIndex)
        {
            // 'value' is value contained in the cell located at
            // (rowIndex, vColIndex)

            if (isSelected)
            {
                // cell (and perhaps other cells) are selected
            }

            if (hasFocus)
            {
                // this cell is the anchor and the table has the focus
            }

            if (null != value)
            {
                // Configure the component with the specified value
                setText(value.toString());
                // Set tool tip if desired          
                setToolTipText(value.toString());
            }

            this.setFont(new java.awt.Font("Lucida Grande", 0, 11));

            // Since the renderer is a component, return itself
            return this;
        }

        // The following methods override the defaults for performance reasons
        @Override
        public void validate()
        {
        }

        @Override
        public void revalidate()
        {
        }

        @Override
        protected void firePropertyChange(String propertyName, Object oldValue, Object newValue)
        {
        }

        @Override
        public void firePropertyChange(String propertyName, boolean oldValue, boolean newValue)
        {
        }
    }

}
